/*
 * Generated by ./misc/optlib2c from optlib/rdoc.ctags, Don't edit this manually.
 */
#include "general.h"
#include "parse.h"
#include "routines.h"
#include "field.h"
#include "xtag.h"


typedef enum {
	K_L1HEADER,
	K_L2HEADER,
	K_L3HEADER,
	K_L4HEADER,
	K_L5HEADER,
	K_L6HEADER,
} RDocKind;


static void initializeRDocParser (const langType language CTAGS_ATTR_UNUSED)
{
	addLanguageOptscriptToHook (language, SCRIPT_HOOK_PRELUDE,
		"{{    /kindTable [\n"
		"        /L1Header /L2Header /L3Header /L4Header /L5Header /L6Header\n"
		"    ] def\n"
		"\n"
		"    /depthForCork {\n"
		"        :kind kindTable exch _aindex pop\n"
		"    } def\n"
		"    /depthForStr {\n"
		"        length 1 sub\n"
		"    } def\n"
		"\n"
		"    % endline:int goal:int scopePopUpTo -\n"
		"    /scopePopUpTo\n"
		"    {\n"
		"        {\n"
		"            _scopetop {\n"
		"                dup\n"
		"                % endline goal scope scope\n"
		"                depthForCork 2 index depthForStr ge {\n"
		"                    % endline goal scope\n"
		"                    2 index end:\n"
		"                    _scopepop\n"
		"                } {\n"
		"                    pop\n"
		"                    exit\n"
		"                } ifelse\n"
		"            } {\n"
		"                exit\n"
		"            } ifelse\n"
		"        } loop\n"
		"        pop\n"
		"        pop\n"
		"    } def\n"
		"}}");
}

extern parserDefinition* RDocParser (void)
{
	static const char *const extensions [] = {
		"rdoc",
		NULL
	};

	static const char *const aliases [] = {
		NULL
	};

	static const char *const patterns [] = {
		NULL
	};

	static kindDefinition RDocKindTable [] = {
		{
		  true, 'h', "L1Header", " Level 1 headers",
		},
		{
		  true, 'i', "L2Header", " Level 2 headers",
		},
		{
		  true, 'j', "L3Header", " Level 3 headers",
		},
		{
		  true, 'k', "L4Header", " Level 4 headers",
		},
		{
		  true, 'l', "L5Header", " Level 5 headers",
		},
		{
		  true, 'm', "L6Header", " Level 6 headers",
		},
	};
	static tagRegexTable RDocTagRegexTable [] = {
		{"^(?:#[ \t])*(={1,6})[ \t]*([^=].*)[ \t]*$", "",
		"", "{pcre2}"
		"{{\n"
		"    \\1 length kindTable length le {\n"
		"        \\2\n"
		"        kindTable \\1 length 1 sub get\n"
		"        2 /start _matchloc\n"
		"        _tag _commit\n"
		"        dup :line 1 sub \\1 scopePopUpTo\n"
		"        _scopetop {\n"
		"            1 index exch scope: _scopepush\n"
		"        } {\n"
		"            _scopepush\n"
		"        } ifelse\n"
		"    } if\n"
		"}}", NULL, false},
	};


	parserDefinition* const def = parserNew ("RDoc");

	def->enabled       = true;
	def->extensions    = extensions;
	def->patterns      = patterns;
	def->aliases       = aliases;
	def->method        = METHOD_NOT_CRAFTED|METHOD_REGEX;
	def->useCork       = CORK_QUEUE;
	def->kindTable     = RDocKindTable;
	def->kindCount     = ARRAY_SIZE(RDocKindTable);
	def->tagRegexTable = RDocTagRegexTable;
	def->tagRegexCount = ARRAY_SIZE(RDocTagRegexTable);
	def->defaultScopeSeparator = "\"\"";
	def->initialize    = initializeRDocParser;

	return def;
}
