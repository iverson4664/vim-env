/*
 * Generated by ./misc/optlib2c from optlib/elixir.ctags, Don't edit this manually.
 */
#include "general.h"
#include "parse.h"
#include "routines.h"
#include "field.h"
#include "xtag.h"


static void initializeElixirParser (const langType language CTAGS_ATTR_UNUSED)
{
}

extern parserDefinition* ElixirParser (void)
{
	static const char *const extensions [] = {
		"ex",
		"exs",
		NULL
	};

	static const char *const aliases [] = {
		NULL
	};

	static const char *const patterns [] = {
		NULL
	};

	static kindDefinition ElixirKindTable [] = {
		{
		  true, 'p', "protocol", "protocols (defprotocol...)",
		},
		{
		  true, 'm', "module", "modules (defmodule ...)",
		},
		{
		  true, 'f', "function", "functions (def ...)",
		},
		{
		  true, 'c', "callback", "callbacks (defcallback ...)",
		},
		{
		  true, 'd', "delegate", "delegates (defdelegate ...)",
		},
		{
		  true, 'e', "exception", "exceptions (defexception ...)",
		},
		{
		  true, 'g', "guard", "guards (defguard ...)",
		},
		{
		  true, 'i', "implementation", "implementations (defimpl ...)",
		},
		{
		  true, 'a', "macro", "macros (defmacro ...)",
		},
		{
		  true, 'o', "operator", "operators (e.g. \"defmacro a <<< b\")",
		},
		{
		  true, 'r', "record", "records (defrecord...)",
		},
		{
		  true, 't', "test", "tests (test ...)",
		},
		{
		  true, 'y', "type", "types (@type ...)",
		},
	};
	static tagRegexTable ElixirTagRegexTable [] = {
		{"^[ \t]*defprotocol[ \t]+([A-Z][a-zA-Z0-9_]*\\.)*([A-Z][a-zA-Z0-9_?!]*)", "\\2",
		"p", "{scope=set}", NULL, false},
		{"^[ \t]*defmodule[ \t]+([A-Z][a-zA-Z0-9_]*\\.)*([A-Z][a-zA-Z0-9_?!]*)", "\\2",
		"m", "{scope=set}", NULL, false},
		{"^[ \t]*def((p?)|macro(p?))[ \t]+([a-zA-Z0-9_?!]+)[ \t]+([\\|\\^/&<>~.=!*+-]{1,3}|and|or|in|(not( +in)?)|when)[ \t]+[a-zA-Z0-9_?!]", "\\5",
		"o", "{scope=ref}{exclusive}", NULL, false},
		{"^[ \t]*def[ \t]+([a-z_][a-zA-Z0-9_?!]*)", "\\1",
		"f", "{scope=ref}{{. (public) access:}}", NULL, false},
		{"^[ \t]*defp[ \t]+([a-z_][a-zA-Z0-9_?!]*)", "\\1",
		"f", "{scope=ref}{{. (private) access:}}", NULL, false},
		{"^[ \t]*(@|def)callback[ \t]+([a-z_][a-zA-Z0-9_?!]*)", "\\2",
		"c", "{scope=ref}", NULL, false},
		{"^[ \t]*defdelegate[ \t]+([a-z_][a-zA-Z0-9_?!]*)", "\\1",
		"d", "{scope=ref}", NULL, false},
		{"^[ \t]*defexception[ \t]+([A-Z][a-zA-Z0-9_]*\\.)*([A-Z][a-zA-Z0-9_?!]*)", "\\2",
		"e", "{scope=ref}{exclusive}", NULL, false},
		{"^[ \t]*defexception[ \t]+", "",
		"", "{exclusive}"
		"{{\n"
		"    _scopetop {\n"
		"        dup :kind /module eq {\n"
		"            dup\n"
		"            :name /exception _tag _commit exch scope:\n"
		"        } if\n"
		"    } if\n"
		"}}", NULL, false},
		{"^[ \t]*defguard[ \t]+(is_[a-zA-Z0-9_?!]+)", "\\1",
		"g", "{scope=ref}{{. (public) access:}}", NULL, false},
		{"^[ \t]*defguardp[ \t]+(is_[a-zA-Z0-9_?!]+)", "\\1",
		"g", "{scope=ref}{{. (private) access:}}", NULL, false},
		{"^[ \t]*defimpl[ \t]+([A-Z][a-zA-Z0-9_]*\\.)*([A-Z][a-zA-Z0-9_?!]*)", "\\2",
		"i", "{scope=ref}", NULL, false},
		{"^[ \t]*defmacro[ \t]+([a-z_][a-zA-Z0-9_?!]*)(.[^\\|\\^/&<>~.=!*+-]+)", "\\1",
		"a", "{scope=ref}{{. (public) access:}}", NULL, false},
		{"^[ \t]*defmacrop[ \t]+([a-z_][a-zA-Z0-9_?!]*)(.[^\\|\\^/&<>~.=!*+-]+)", "\\1",
		"a", "{scope=ref}{{. (private) access:}}", NULL, false},
		{"^[ \t]*Record\\.defrecord[ \t(]+:([a-zA-Z0-9_]+)(\\)?)", "\\1",
		"r", "{scope=ref}{{. (public) access:}}", NULL, false},
		{"^[ \t]*Record\\.defrecordp[ \t(]+:([a-zA-Z0-9_]+)(\\)?)", "\\1",
		"r", "{scope=ref}{{. (private) access:}}", NULL, false},
		{"^[ \t]*test[ \t(]+\"([a-z_][a-zA-Z0-9_?! ]*)\"*(\\)?)[ \t]*do", "\\1",
		"t", "{scope=ref}", NULL, false},
		{"^[ \t]*@(type|opaque)[ \t]+([a-z_][a-zA-Z0-9_?!]*)", "\\2",
		"y", "{scope=ref}{{. (public) access:}}", NULL, false},
		{"^[ \t]*@typep[ \t]+([a-z_][a-zA-Z0-9_?!]*)", "\\1",
		"y", "{scope=ref}{{. (private) access:}}", NULL, false},
	};


	parserDefinition* const def = parserNew ("Elixir");

	def->enabled       = true;
	def->extensions    = extensions;
	def->patterns      = patterns;
	def->aliases       = aliases;
	def->method        = METHOD_NOT_CRAFTED|METHOD_REGEX;
	def->useCork       = CORK_QUEUE;
	def->kindTable     = ElixirKindTable;
	def->kindCount     = ARRAY_SIZE(ElixirKindTable);
	def->tagRegexTable = ElixirTagRegexTable;
	def->tagRegexCount = ARRAY_SIZE(ElixirTagRegexTable);
	def->initialize    = initializeElixirParser;

	return def;
}
